<chapter id="querysql">
    <title>Native SQL Queries</title>

    <para>
        You may also express queries in the native SQL dialect of your database. This is useful if you
        want to utilize database specific features such as the CONNECT keyword in Oracle.
        This also allows for a cleaner migration path from a direct SQL/JDBC based application to 
        Hibernate.
    </para>

    <sect1 id="querysql-creating">
        <title>Creating a SQL based <literal>Query</literal></title>

        <para>
            SQL queries are exposed through the same <literal>Query</literal> interface, just like ordinary
            HQL queries. The only difference is the use of <literal>Session.createSQLQuery()</literal>.
        </para>

        <programlisting><![CDATA[Query sqlQuery = sess.createSQLQuery("select {cat.*} from cats {cat}", "cat", Cat.class);
sqlQuery.setMaxResults(50);
List cats = sqlQuery.list();]]></programlisting>

        <para>
            The three parameters provided to <literal>createSQLQuery()</literal> are:
        </para>

        <itemizedlist>
        <listitem>
        <para>
            the SQL query string
        </para>
        </listitem>
        <listitem>
        <para>
            a table alias name
        </para>
        </listitem>
        <listitem>
        <para>
            the persistent class returned by the query
        </para>
        </listitem>
        </itemizedlist>
    
        <para>
            The alias name is used inside the sql string to refer to the properties of the mapped class
            (in this case  <literal>Cat</literal>). You may retrieve multiple objects per row by supplying
            a <literal>String</literal> array of alias names and a <literal>Class</literal> array of
            corresponding classes.
        </para>

    </sect1>

    <sect1 id="querysql-aliasreferences">
        <title>Alias and property references</title>

        <para>
            The <literal>{cat.*}</literal> notation used above is a shorthand for "all properties". You
            may even list the properties explicity, but you must let Hibernate provide SQL column aliases
            for each property. The placeholders for these column aliases are the property name qualified by
            the table alias. In the following example, we retrieve <literal>Cat</literal>s from a different
            table (<literal>cat_log</literal>) to the one declared in the mapping metadata. Notice that we
            may even use the property aliases in the where clause.
        </para>

        <programlisting><![CDATA[String sql = "select cat.originalId as {cat.id}, "
    + "  cat.mateid as {cat.mate}, cat.sex as {cat.sex}, "
    + "  cat.weight*10 as {cat.weight}, cat.name as {cat.name}"
    + "     from cat_log cat where {cat.mate} = :catId"
List loggedCats = sess.createSQLQuery(sql, "cat", Cat.class)
    .setLong("catId", catId)
    .list();
]]></programlisting>

        <para>
            <emphasis>Note:</emphasis> if you list each property explicitly, you must include all
            properties of the class <emphasis>and its subclasses</emphasis>!
        </para>

    </sect1>
    
    <sect1 id="querysql-namedqueries">
        <title>Named SQL queries</title>

        <para>
            Named SQL queries may be defined in the mapping document and called in exactly the same way
            as a named HQL query.
        </para>

        <programlisting><![CDATA[List people = sess.getNamedQuery("mySqlQuery")
    .setMaxResults(50)
    .list();]]></programlisting>

        <programlisting><![CDATA[<sql-query name="mySqlQuery">
    <return alias="person" class="eg.Person"/>
    SELECT {person}.NAME AS {person.name},
           {person}.AGE AS {person.age},
           {person}.SEX AS {person.sex}
    FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
</sql-query>]]></programlisting>

    </sect1>

</chapter>