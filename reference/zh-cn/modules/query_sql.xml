<chapter id="querysql" revision="2">
    <title>Native SQL查询</title>
    <para>
		你也可以使用你的数据库的Native SQL语言来查询数据。这对你在要使用数据库的某些特性的时候(比如说在查询提示或者Oracle中的
		<literal>CONNECT</literal>关键字)，这是非常有用的。这就能够扫清你把原来直接使用SQL/JDBC 的程序迁移到基于
		Hibernate应用的道路上的障碍。
    </para>

    <para>
		Hibernate3允许你使用手写的sql来完成所有的create,update,delete,和load操作（包括存储过程）
    </para>

    <sect1 id="querysql-creating" revision="3">
    <title>使用<literal>SQLQuery</literal></title>

    <para>对原生SQL查询执行的控制是通过<literal>SQLQuery</literal>接口进行的，通过执行<literal>Session.createSQLQuery()</literal>获取这个接口。最简单的情况下，我们可以采用以下形式：</para>

    <programlisting><![CDATA[List cats = sess.createSQLQuery("select * from cats")
    .addEntity(Cat.class)
    .list();]]></programlisting>

    <para>这个查询指定了:</para>

    <itemizedlist>
      <listitem>
        <para>SQL查询字符串</para>
      </listitem>

      <listitem>
        <para>查询返回的实体</para>
      </listitem>
    </itemizedlist>

    <para>这里，结果集字段名被假设为与映射文件中指明的字段名相同。对于连接了多个表的查询，这就可能造成问题，因为可能在多个表中出现同样名字的字段。下面的方法就可以避免字段名重复的问题:</para>

    <programlisting><![CDATA[List cats = sess.createSQLQuery("select {cat.*} from cats cat")
    .addEntity("cat", Cat.class)
    .list();]]></programlisting>

        <para>
			这个查询指定了:
        </para>

        <itemizedlist>
        <listitem>
        <para>
			SQL查询语句，它带一个占位符，可以让Hibernate使用字段的别名.
        </para>
        </listitem>
        <listitem>
        <para>
			查询返回的实体，和它的SQL表的别名.
        </para>
        </listitem>
        </itemizedlist>
    
        <para>
			<literal>addEntity()</literal>方法将SQL表的别名和实体类联系起来，并且确定查询结果集的形态。
        </para>
        
        <para>
			<literal>addJoin()</literal>方法可以被用于载入其他的实体和集合的关联.
        </para>
    
    <programlisting><![CDATA[List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .addEntity("cat", Cat.class)
    .addJoin("kitten", "cat.kittens")
    .list();]]></programlisting>
            
        <para>
			原生的SQL查询可能返回一个简单的标量值或者一个标量和实体的结合体。
        </para>

        <programlisting><![CDATA[Double max = (Double) sess.createSQLQuery("select max(cat.weight) as maxWeight from cats cat")
        .addScalar("maxWeight", Hibernate.DOUBLE);
        .uniqueResult();]]></programlisting>
        
    <para>除此之外，你还可以在你的hbm文件中描述结果集映射信息，在查询中使用。</para>
    
    <programlisting><![CDATA[List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .setResultSetMapping("catAndKitten")
    .list();]]></programlisting>


    </sect1>

    <sect1 id="querysql-aliasreferences">
        <title>别名和属性引用</title>

        <para>
			上面使用的<literal>{cat.*}</literal>标记是 "所有属性" 的简写.你可以显式地列出需要的字段,但是你必须让Hibernate
			为每一个属性注入字段的别名.这些字段的站位符是以字段别名为前导,再加上属性名.在下面的例子里,我们从一个其他的表(<literal>cat_log</literal>)
			中获取<literal>Cat</literal>对象,而非Cat对象原本在映射元数据中声明的表.注意我们甚至在where子句中也可以使用属性别名.
            对于命名查询,{}语法并不是必需的.你可以在<xref linkend="querysql-namedqueries"/>得到更多的细节.
        </para>

        <programlisting><![CDATA[String sql = "select cat.originalId as {cat.id}, " +
    "cat.mateid as {cat.mate}, cat.sex as {cat.sex}, " +
    "cat.weight*10 as {cat.weight}, cat.name as {cat.name} " +
    "from cat_log cat where {cat.mate} = :catId"
    
List loggedCats = sess.createSQLQuery(sql)
    .addEntity("cat", Cat.class)
    .setLong("catId", catId)
    .list();]]></programlisting>

        <para>
            <emphasis>注意:</emphasis>如果你明确地列出了每个属性,你必须包含<emphasis>这个类</emphasis>和<emphasis>它的子类</emphasis>的属性!
        </para>

    <para>
    下表列出了使用别名注射参数的不同可能性。注意：下面结果中的别名只是示例，实用时每个别名需要唯一并且不同的名字。
    </para>

    <table frame="topbot" id="aliasinjection-summary">
      <title>别名注射(alias injection names)</title>

      <tgroup cols="4">
        <colspec colwidth="1*" />

        <colspec colwidth="1*" />

        <colspec colwidth="2.5*" />

        <thead>
          <row>
            <entry>描述</entry>
            <entry>语法</entry>
            <entry>示例</entry>
            </row>
        </thead>
        <tbody>
          <row>
            <entry>简单属性</entry>
            <entry><literal>{[aliasname].[propertyname]</literal></entry>
            <entry><literal>A_NAME as {item.name}</literal></entry>
          </row>
          <row>
            <entry>复合属性</entry>
            <entry><literal>{[aliasname].[componentname].[propertyname]}</literal></entry>
            <entry><literal>CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</literal></entry>
          </row>
          <row>
            <entry>实体辨别器(Discriminator of an entity)</entry>
            <entry><literal>{[aliasname].class}</literal></entry>
            <entry><literal>DISC as {item.class}</literal></entry>
          </row>
          <row>
            <entry>实体的所有属性</entry>
            <entry><literal>{[aliasname].*}</literal></entry>
            <entry><literal>{item.*}</literal></entry>
          </row>
          <row>
            <entry>集合键(collection key)</entry>
            <entry><literal>{[aliasname].key}</literal></entry>
            <entry><literal>ORGID as {coll.key}</literal></entry>
          </row>
          <row>
            <entry>集合id</entry>
            <entry><literal>{[aliasname].id}</literal></entry>
            <entry><literal>EMPID as {coll.id}</literal></entry>
          </row>
          <row>
            <entry>集合元素</entry>
            <entry><literal>{[aliasname].element}</literal></entry>
            <entry><literal>XID as {coll.element}</literal></entry>
            <entry></entry>
          </row>
          <row>
            <entry>集合元素的属性</entry>
            <entry><literal>{[aliasname].element.[propertyname]}</literal></entry>
            <entry><literal>NAME as {coll.element.name}</literal></entry>
          </row>
          <row>
            <entry>集合元素的所有属性</entry>
            <entry><literal>{[aliasname].element.*}</literal></entry>
            <entry><literal>{coll.element.*}</literal></entry>
          </row>
          <row>
            <entry>集合的所有属性</entry>
            <entry><literal>{[aliasname].*}</literal></entry>
            <entry><literal>{coll.*}</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </table>


    </sect1>
    
    <sect1 id="querysql-namedqueries" revision="3">
        <title>命名SQL查询</title>

        <para>
			可以在映射文档中定义查询的名字,然后就可以象调用一个命名的HQL查询一样直接调用命名SQL查询.在这种情况下,我们<emphasis>不</emphasis>
			需要调用<literal>addEntity()</literal>方法.
        </para>

         <programlisting><![CDATA[<sql-query name="persons">
    <return alias="person" class="eg.Person"/>
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
</sql-query>]]></programlisting>

    <programlisting><![CDATA[List people = sess.getNamedQuery("persons")
    .setString("namePattern", namePattern)
    .setMaxResults(50)
    .list();]]></programlisting>
    
    <para><literal>&lt;return-join&gt;</literal>和
    <literal>&lt;load-collection&gt;</literal> 元素是用来连接关联以及将查询定义为预先初始化各个集合的。</para>

    <programlisting><![CDATA[<sql-query name="personsWith">
    <return alias="person" class="eg.Person"/>
    <return-join alias="address" property="person.mailingAddress"/>
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           adddress.STREET AS {address.street},
           adddress.CITY AS {address.city},
           adddress.STATE AS {address.state},
           adddress.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
</sql-query>]]></programlisting>
    

        <para>
			一个命名查询可能会返回一个标量值.你必须使用<literal>&lt;return-scalar&gt;</literal>元素来指定字段的别名和
			Hibernate类型
        </para>
        
        <programlisting><![CDATA[<sql-query name="mySqlQuery">
    <return-scalar column="name" type="string"/>
    <return-scalar column="age" type="long"/>
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
</sql-query>]]></programlisting>

    <para>
    你可以把结果集映射的信息放在外部的<literal>&lt;resultset&gt;</literal>元素中，这样就可以在多个命名查询间，或者通过<literal>setResultSetMapping()</literal>API来访问。(此处原文即存疑。原文为：You can externalize the resultset mapping informations in a
    <literal>&lt;resultset&gt;</literal> element to either reuse them accross
    several named queries or through the
    <literal>setResultSetMapping()</literal> API.)
    </para>

    <programlisting><![CDATA[<resultset name="personAddress">
    <return alias="person" class="eg.Person"/>
    <return-join alias="address" property="person.mailingAddress"/>
</resultset>

<sql-query name="personsWith" resultset-ref="personAddress">
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           adddress.STREET AS {address.street},
           adddress.CITY AS {address.city},
           adddress.STATE AS {address.state},
           adddress.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
</sql-query>]]></programlisting>
         
         <sect2 id="propertyresults">
             <title>使用return-property来明确地指定字段/别名</title>
             
             <para>
				使用<literal>&lt;return-property&gt;</literal>你可以明确的告诉Hibernate使用哪些字段别名,这取代了使用<literal>{}</literal>-语法
				来让Hibernate注入它自己的别名.
             </para>
             
            <programlisting><![CDATA[<sql-query name="mySqlQuery">
    <return alias="person" class="eg.Person">
      <return-property name="name" column="myName"/>
      <return-property name="age" column="myAge"/>
      <return-property name="sex" column="mySex"/>
    </return>
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
</sql-query>
]]></programlisting>
             <literal>&lt;return-property&gt;</literal>也可用于多个字段,它解决了使用<literal>{}</literal>-语法不能细粒度控制多个字段的限制
             <programlisting><![CDATA[<sql-query name="organizationCurrentEmployments">
            <return alias="emp" class="Employment">            
             <return-property name="salary"> 
               <return-column name="VALUE"/>
               <return-column name="CURRENCY"/>            
             </return-property>
             <return-property name="endDate" column="myEndDate"/>
            </return>
            SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer}, 
            STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
            REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
            FROM EMPLOYMENT
            WHERE EMPLOYER = :id AND ENDDATE IS NULL
            ORDER BY STARTDATE ASC
</sql-query>]]></programlisting>
             
            <para>
				注意在这个例子中,我们使用了<literal>&lt;return-property&gt;</literal>结合<literal>{}</literal>的注入语法.
				允许用户来选择如何引用字段以及属性.
            </para>

            <para>
			 如果你映射一个识别器(discriminator),你必须使用<literal>&lt;return-discriminator&gt;</literal> 来指定识别器字段
            </para>
         </sect2>
         
         <sect2 id="sp_query"  revision="1">
             <title>使用存储过程来查询</title>
             
             <para>
				 Hibernate 3引入了对存储过程查询(stored procedure)和函数(function)的支持.以下的说明中，这二者一般都适用。
				 
				 存储过程/函数必须返回一个结果集,作为Hibernate能够使用的第一个外部参数.
				 
				 下面是一个Oracle9和更高版本的存储过程例子.</para>
                 
                 <programlisting><![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments 
    RETURN SYS_REFCURSOR 
AS 
    st_cursor SYS_REFCURSOR; 
BEGIN 
    OPEN st_cursor FOR 
 SELECT EMPLOYEE, EMPLOYER, 
 STARTDATE, ENDDATE, 
 REGIONCODE, EID, VALUE, CURRENCY 
 FROM EMPLOYMENT; 
      RETURN  st_cursor; 
 END;]]></programlisting>
             <para>    
				 在Hibernate里要要使用这个查询,你需要通过命名查询来映射它.
			 </para>
                 
             <programlisting><![CDATA[<sql-query name="selectAllEmployees_SP" callable="true">
    <return alias="emp" class="Employment">
        <return-property name="employee" column="EMPLOYEE"/>
        <return-property name="employer" column="EMPLOYER"/>            
        <return-property name="startDate" column="STARTDATE"/>
        <return-property name="endDate" column="ENDDATE"/>            
        <return-property name="regionCode" column="REGIONCODE"/>            
        <return-property name="id" column="EID"/>                        
        <return-property name="salary"> 
            <return-column name="VALUE"/>
            <return-column name="CURRENCY"/>            
        </return-property>
    </return>
    { ? = call selectAllEmployments() }
</sql-query>]]></programlisting>
             
             <para>
			  注意存储过程当前仅仅返回标量和实体.现在不支持<literal>&lt;return-join&gt;</literal>和<literal>&lt;load-collection&gt;</literal>
			  
             </para>
             
             <sect3 id="querysql-limits-storedprocedures"  revision="1">
               <title>使用存储过程的规则和限制</title>
               
               <para>
				   为了在Hibernate中使用存储过程,你必须遵循一些规则.不遵循这些规则的存储过程将不可用.如果你仍然想要使用他们,
				   你必须通过<literal>session.connection()</literal>来执行他们.这些规则针对于不同的数据库.因为数据库
				   提供商有各种不同的存储过程语法和语义.
               </para>
               
               <para>
                   对存储过程进行的查询无法使用<literal>setFirstResult()/setMaxResults()</literal>进行分页。
               </para>
               
               
        <para>建议采用的调用方式是标准SQL92: <literal>{ ? = call
        functionName(&lt;parameters&gt;) }</literal> 或者 <literal>{ ? = call
        procedureName(&lt;parameters&gt;}</literal>.原生调用语法不被支持。</para>

               <para>
				   对于Oracle有如下规则:
               </para>
               
               <itemizedlist spacing="compact">
          <listitem>
            <para>函数必须返回一个结果集。存储过程的第一个参数必须是<literal>OUT</literal>，它返回一个结果集。这是通过Oracle 9或10的<literal>SYS_REFCURSOR</literal>类型来完成的。在Oracle中你需要定义一个<literal>REF CURSOR</literal>类型，参见Oracle的手册。</para>
          </listitem>
              </itemizedlist>
                           
              <para>                   
				   对于Sybase或者MS SQL server有如下规则:
               </para>
                   
               <itemizedlist spacing="compact">
               <listitem>
               <para>    
				   存储过程必须返回一个结果集。.注意这些servers可能返回多个结果集以及更新的数目.Hibernate将取出第一条结果集作为它的返回值，
				   其他将被丢弃。
               </para>
               </listitem>    
               <listitem>
               <para>    
				   如果你能够在存储过程里设定<literal>SET NOCOUNT ON</literal>，这可能会效率更高，但这不是必需的。
               </para>
               </listitem>    
              </itemizedlist>
              </sect3>
         </sect2>

    </sect1>

    <sect1 id="querysql-cud">
        <title>定制SQL用来create，update和delete</title>

        <para>
			Hibernate3能够使用定制的SQL语句来执行create,update和delete操作。在Hibernate中，持久化的类和集合已经
			包含了一套配置期产生的语句(insertsql, deletesql, updatesql等等)，这些映射标记 <literal>&lt;sql-insert&gt;</literal>, 
			<literal>&lt;sql-delete&gt;</literal>, and <literal>&lt;sql-update&gt;</literal>重载了
			这些语句。
        </para>

        <programlisting><![CDATA[<class name="Person">
    <id name="id">
        <generator class="increment"/>
    </id>
    <property name="name" not-null="true"/>
    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-insert>
    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>
    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>
</class>]]></programlisting>

        <para>
			这些SQL直接在你的数据库里执行，所以你可以自由的使用你喜欢的任意语法。但如果你使用数据库特定的语法，
			这当然会降低你映射的可移植性。
        </para>

        <para>
			如果设定<literal>callable</literal>，则能够支持存储过程了。
        </para>

    <programlisting><![CDATA[<class name="Person">
    <id name="id">
        <generator class="increment"/>
    </id>
    <property name="name" not-null="true"/>
    <sql-insert callable="true">{call createPerson (?, ?)}</sql-insert>
    <sql-delete callable="true">{? = call deletePerson (?)}</sql-delete>
    <sql-update callable="true">{? = call updatePerson (?, ?)}</sql-update>
</class>]]></programlisting>

        <para>
		  参数的位置顺序是非常重要的，他们必须和Hibernate所期待的顺序相同。
        </para>
        
        <para>
		  你能够通过设定日志调试级别为<literal>org.hiberante.persister.entity</literal>,来查看Hibernate所期待的顺序。在这个级别下，
		  Hibernate将会打印出create,update和delete实体的静态SQL。(如果想看到预计的顺序。记得不要将定制SQL包含在映射文件里，
		  因为他们会重载Hibernate生成的静态SQL。)
        </para>

        <para>
			在大多数情况下(最好这么做)，存储过程需要返回插入/更新/删除的行数，因为Hibernate对语句的成功执行有些运行时的检查。
			Hibernate常会把进行CUD操作的语句的第一个参数注册为一个数值型输出参数。
        </para>

        <programlisting><![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;]]></programlisting>

        
    </sect1>

    <sect1 id="querysql-load">
        <title>定制装载SQL</title>

        <para>
			你可能需要声明你自己的SQL(或HQL)来装载实体
        </para>

    <programlisting><![CDATA[<sql-query name="person">
    <return alias="pers" class="Person" lock-mode="upgrade"/>
    SELECT NAME AS {pers.name}, ID AS {pers.id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
</sql-query>]]></programlisting>

        <para>
			这只是一个前面讨论过的命名查询声明，你可以在类映射里引用这个命名查询。
        </para>

        <programlisting><![CDATA[<class name="Person">
    <id name="id">
        <generator class="increment"/>
    </id>
    <property name="name" not-null="true"/>
    <loader query-ref="person"/>
</class>]]></programlisting>
    
        <para>
		    这也可以用于存储过程
        </para>

    <para>你甚至可以定一个用于集合装载的查询:</para>

    <programlisting><![CDATA[<set name="employments" inverse="true">
    <key/>
    <one-to-many class="Employment"/>
    <loader query-ref="employments"/>
</set>]]></programlisting>

    <programlisting><![CDATA[<sql-query name="employments">
    <load-collection alias="emp" role="Person.employments"/>
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
</sql-query>]]></programlisting>

    <para>你甚至还可以定义一个实体装载器，它通过连接抓取装载一个集合:</para>

    <programlisting><![CDATA[<sql-query name="person">
    <return alias="pers" class="Person"/>
    <return-join alias="emp" property="pers.employments"/>
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
</sql-query>]]></programlisting>
  </sect1>

</chapter>