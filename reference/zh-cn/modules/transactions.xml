<chapter id="transactions" revision="1">
	<title>事务和并发</title>
	<para>
			Hibernate的事务和并发控制很容易掌握。Hibernate直接使用JDBC连接和JTA资源，不添加任何附加锁定
			行为。我们强烈推荐你花点时间了解JDBC编程，ANSI SQL查询语言和你使用
			的数据库系统的事务隔离规范。Hibernate只添加自动版本管理，而不会锁
			定内存中的对象，也不会改变数据库事务的隔离级别。基本上，使用
			Hibernate就好像直接使用JDBC(或者JTA/CMT)来访问你的数据库资源。
	</para>
		<para>
				除了自动版本管理，针对行级悲观锁定，Hibernate也提供了辅助的API，它使用了
				<literal>SELECT FOR UPDATE</literal>的SQL语法。本章后面会讨论这个API。
		</para>
		<para>
					我们从<literal>Configuration</literal>层、<literal>SessionFactory</literal>层, 和
      		<literal>Session</literal>层开始讨论Hibernate的并行控制、数据库事务和应用
        	程序的长事务。
	</para>
    <sect1 id="transactions-basics">
	   <title>Session和事务范围(transaction scopes)</title>
				<para>
						一个<literal>SessionFactory</literal>对象的创建代价很昂贵，它是线程安全的对象，它被设计成可以
						为所有的应用程序线程所共享。它只创建一次，通常是在应用程序启动的时候，由一个
						<literal>Configuraion</literal>的实例来创建。				
				</para>
				<para>
						一个<literal>Session</literal>的对象是轻型的，非线程安全的，对于单个业务进程，单个的
						工作单元而言，它只被使用一次，然后就丢弃。只有在需要的时候，<literal>Session</literal>
						才会获取一个JDBC的<literal>Connection</literal>（或一个<literal>Datasource</literal>）
						对象。所以你可以放心的打开和关闭<literal>Session</literal>，甚至当你并不确定一个特定的请
						求是否需要数据访问时，你也可以这样做。(一旦你实现下面提到的使用了请求拦截的模式，这就
						变得很重要了。
				</para>
				<para>
					此外我们还要考虑数据库事务。数据库事务应该尽可能的短，降低数据库锁定造成的资源争用。
					数据库长事务会导致你的应用程序无法扩展到高的并发负载。
				</para>
		<para>
				一个操作单元(Unit of work)的范围是多大？单个的Hibernate <literal>Session</literal>能跨越多个
				数据库事务吗？还是一个<literal>Session</literal>的作用范围对应一个数据库事务的范围？应该何时打开
				<literal>Session</literal>，何时关闭<literal>Session</literal>？，你又如何划分数据库事务的边界呢？
		</para>
        <sect2 id="transactions-basics-uow">
						<title>操作单元(Unit of work)</title>
		<para>
				首先，别再用<emphasis>session-per-operation</emphasis>这种反模式了，也就是说，在单个线程中，
				不要因为一次简单的数据库调用，就打开和关闭一次<literal>Session</literal>！数据库事务也是如此。
				应用程序中的数据库调用是按照计划好的次序，分组为原子的操作单元。（注意，这也意味着，应用程
				序中，在单个的SQL语句发送之后，自动事务提交(auto-commit)模式失效了。这种模式专门为SQL控制台操作设计的。
				Hibernate禁止立即自动事务提交模式，或者期望应用服务器禁止立即自动事务提交模式。）
		</para>
		<para>
				在多用户的client/server应用程序中，最常用的模式是 <emphasis>每个请求一个会话(session-per-request)</emphasis>。
				在这种模式下，来自客户端的请求被发送到服务器端（即Hibernate持久化层运行的地方），一
				个新的Hibernate <literal>Session</literal>被打开，并且执行这个操作单元中所有的数据库操作。
				一旦操作完成（同时发送到客户端的响应也准备就绪），session被同步，然后关闭。你也可以使用单
				个数据库事务来处理客户端请求，在你打开<literal>Session</literal>之后启动事务，在你关闭
				<literal>Session</literal>之前提交事务。会话和请求之间的关系是一对一的关系，这种模式对
				于大多数应用程序来说是很棒的。
		</para>
			<para>
					真正的挑战在于如何去实现这种模式：不仅<literal>Session</literal>和事务必须被正确的开始和结束，
					而且他们也必须能被数据访问操作访问。用拦截器来实现操作单元的划分，该拦截器在客户端请求达到服
					务器端的时候开始，在服务器端发送响应（即，<literal>ServletFilter</literal>）之前结束。我们推荐
					使用一个<literal>ThreadLocal</literal> 变量，把 <literal>Session</literal>绑定到处理客户端请求的线
					程上去。这种方式可以让运行在该线程上的所有程序代码轻松的访问<literal>Session</literal>（就像访问一
					个静态变量那样）。你也可以在一个<literal>ThreadLocal</literal> 变量中保持事务上下文环境，不过这依赖
					于你所选择的数据库事务划分机制。这种实现模式被称之为 <emphasis>ThreadLocal Session</emphasis>和
					<emphasis>Open Session in View</emphasis>。你可以很容易的扩展本文前面章节展示的 
					<literal>HibernateUtil</literal> 辅助类来实现这种模式。当然，你必须找到一种实现拦截器的方法，并
					且可以把拦截器集成到你的应用环境中。请参考Hibernate网站上面的提示和例子。
			</para>
        </sect2>

        <sect2 id="transactions-basics-apptx">
						<title>应用程序事务(Application transactions)</title>
						<para>
							session-per-request模式不仅仅是一个可以用来设计操作单元的有用概念。很多业务处理流程都需
							要一系列完整的和用户之间的交互，即用户对数据库的交叉访问。在基于web的应用和企业
							应用中，跨用户交互的数据库事务是无法接受的。考虑下面的例子：
						</para>
            <itemizedlist>
                <listitem>
										<para>
												在界面的第一屏，打开对话框，用户所看到的数据是被一个特定的 <literal>Session</literal> 和数据
												库事务载入(load)的。用户可以随意修改对话框中的数据对象。
										</para>
                </listitem>
                <listitem>
				<para>
						5分钟后，用户点击“保存”，期望所做出的修改被持久化；同时他也期望自己是唯一修改这个信息的人，不会出现
						修改冲突。
				</para>
                </listitem>
            </itemizedlist>

		<para>
				从用户的角度来看，我们把这个操作单元称为<emphasis>应用程序长事务</emphasis>（application transaction）。
				在你的应用程序中，可以有很多种方法来实现它。
		</para>
		<para>
				头一个幼稚的做法是，在用户思考的过程中，保持<literal>Session</literal>和数据库事务是打开的，
				保持数据库锁定，以阻止并发修改，从而保证数据库事务隔离级别和原子操作。这种方式当然是一个反模式，
				因为数据库锁定的维持会导致应用程序无法扩展并发用户的数目。
		 </para>
		<para>
				很明显，我们必须使用多个数据库事务来实现一个应用程序事务。在这个例子中，维护业务处理流程的
				事务隔离变成了应用程序层的部分责任。单个应用程序事务通常跨越多个数据库事务。如果仅仅只有一
				个数据库事务（最后的那个事务）保存更新过的数据，而所有其他事务只是单纯的读取数据（例如在一
				个跨越多个请求/响应周期的向导风格的对话框中），那么应用程序事务将保证其原子性。这种方式比听
				起来还要容易实现，特别是当你使用了Hibernate的下述特性的时候：
		</para>

            <itemizedlist>
                <listitem>
										<para>
										<emphasis>自动版本化</emphasis> - Hibernate能够自动进行乐观并发控制 ，如果在用户思考
										的过程中发生并发修改冲突，Hibernate能够自动检测到。
				</para>
                </listitem>
                <listitem>
				<para>
						<emphasis>脱管对象</emphasis>（Detached Objects）- 如果你决定采用前面已经讨论过的 
						<emphasis>session-per-request</emphasis>模式，所有载入的实例在用户思考的过程
						中都处于与Session脱离的状态。Hibernate允许你把与Session脱离的对象重新关联到Session
						上，并且对修改进行持久化，这种模式被称为
						<emphasis>session-per-request-with-detached-objects</emphasis>。自动版本化被用来隔离并发修改。
				</para>
                </listitem>
                <listitem>
				<para>
						<emphasis>长生命周期的Session</emphasis> （Long Session）- Hibernate 的<literal>Session</literal>
						可以在数据库事务提交之后和底层的JDBC连接断开，当一个新的客户端请求到来的时候，它又重新连接上底层的
						JDBC连接。这种模式被称之为<emphasis>session-per-application-transaction</emphasis>，这种情况可
						能会造成不必要的Session和JDBC连接的重新关联。自动版本化被用来隔离并发修改。
				</para>
                </listitem>
            </itemizedlist>

		<para>
			 <emphasis>session-per-request-with-detached-objects</emphasis> 和
			 <emphasis>session-per-application-transaction</emphasis> 各有优缺点，我们在本章后面乐观并发
			 控制那部分再进行讨论。
		</para>
        </sect2>

        <sect2 id="transactions-basics-identity">
						<title>关注对象标识(Considering object identity)</title>
						<para>
							应用程序可能在两个不同的<literal>Session</literal>中并发访问同一持久化状态，但是，
							一个持久化类的实例无法在两个 <literal>Session</literal>中共享。因此有两种不同的标识语义：
						</para>
		<para>
            <variablelist spacing="compact">
                <varlistentry>
										<term>数据库标识</term>
                    <listitem>
                        <para>
                            <literal>foo.getId().equals( bar.getId() )</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
										<term>JVM 标识</term>
                    <listitem>
                        <para>
                            <literal>foo==bar</literal>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

						<para>
							对于那些关联到 <emphasis>特定</emphasis><literal>Session</literal>
							（也就是在单个<literal>Session</literal>的范围内）上的对象来说，这
							两种标识的语义是等价的，与数据库标识对应的JVM标识是由Hibernate来保
							证的。不过，当应用程序在两个不同的session中并发访问具有同一持久化标
							识的业务对象实例的时候，这个业务对象的两个实例事实上是不相同的（从
							JVM识别来看）。这种冲突可以通过在同步和提交的时候使用自动版本化和乐
							观锁定方法来解决。
						</para>
						<para>
								这种方式把关于并发的头疼问题留给了Hibernate和数据库；由于在单个线程内，操作单元中的对象识别不
								需要代价昂贵的锁定或其他意义上的同步，因此它同时可以提供最好的可伸缩性。只要在单个线程只持有一个
								<literal>Session</literal>，应用程序就不需要同步任何业务对象。在<literal>Session</literal>
								的范围内，应用程序可以放心的使用<literal>==</literal>进行对象比较。
						</para>
						<para>
								不过，应用程序在<literal>Session</literal>的外面使用<literal>==</literal>进行对象比较可能会
								导致无法预期的结果。在一些无法预料的场合，例如，如果你把两个脱管对象实例放进同一个
								<literal>Set</literal>的时候，就可能发生。这两个对象实例可能有同一个数据库标识（也就是说，
								他们代表了表的同一行数据），从JVM标识的定义上来说，对脱管的对象而言，Hibernate无法保证他们
								的的JVM标识一致。开发人员必须覆盖持久化类的<literal>equals()</literal>方法和 
								<literal>hashCode()</literal> 方法，从而实现自定义的对象相等语义。警告：不要使用数据库标识
								来实现对象相等，应该使用业务键值，由唯一的，通常不变的属性组成。当一个瞬时对象被持久化的时
								候，它的数据库标识会发生改变。如果一个瞬时对象（通常也包括脱管对象实例）被放入一
								个<literal>Set</literal>，改变它的hashcode会导致与这个<literal>Set</literal>的关系中断。虽
								然业务键值的属性不象数据库主键那样稳定不变，但是你只需要保证在同一个<literal>Set</literal>
								中的对象属性的稳定性就足够了。请到Hibernate网站去寻求这个问题更多的详细的讨论。请注意，这不是一
								个有关Hibernate的问题，而仅仅是一个关于Java对象标识和判等行为如何实现的问题。
		 				</para>
		 </para>
        </sect2>

        <sect2 id="transactions-basics-issues">
						<title>常见问题</title>
						<para>
								决不要使用反模式<emphasis>session-per-user-session</emphasis>或者<emphasis>
								session-per-application</emphasis>（当然，这个规定几乎没有例外）。请注意，
								下述一些问题可能也会出现在我们推荐的模式中，在你作出某个设计决定之前，请务必理解该模式的应用前提。
						</para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>Session</literal> 是一个非线程安全的类。如果一个<literal>Session</literal>
                        实例允许共享的话，那些支持并发运行的东东，例如HTTP request，session beans,或者是
                        Swing workers，将会导致出现资源争用（race condition）。如果在<literal>HttpSession</literal>中有
                        Hibernate 的<literal>Session</literal>的话（稍后讨论），你应该考虑同步访问你的Http session。
                        否则，只要用户足够快的点击浏览器的“刷新”，就会导致两个并发运行线程使用同一个
                         <literal>Session</literal>。
                    </para>
                </listitem>
                <listitem>
                     <para>
					 								一个由Hibernate抛出的异常意味着你必须立即回滚数据库事务，并立即关闭<literal>Session</literal>
					 								（稍后会展开讨论）。如果你的<literal>Session</literal>绑定到一个应用程序上，你必
					 								须停止该应用程序。回滚数据库事务并不会把你的业务对象退回到事务启动时候的状态。这
					 								意味着数据库状态和业务对象状态不同步。通常情况下，这不是什么问题，因为异常是不可
					 								恢复的,你必须在回滚之后重新开始执行。
                    </para>
               </listitem>
                <listitem>
                    <para>
                        <literal>Session</literal> 缓存了处于持久化状态的每个对象（Hibernate会监视和检查脏数据）。
                        这意味着，如果你让<literal>Session</literal>打开很长一段时间，或是仅仅载入了过多的数据，
                        <literal>Session</literal>占用的内存会一直增长，直到抛出OutOfMemoryException异常。这个
                        问题的一个解决方法是调用<literal>clear()</literal> 和<literal>evict()</literal>来管理
                        <literal>Session</literal>的缓存，但是如果你需要大批量数据操作的话，最好考虑
                        使用存储过程。在<xref linkend="batch"/>中有一些解决方案。在用户会话期间一直保持
                        <literal>Session</literal>打开也意味着出现脏数据的可能性很高。
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

    </sect1>

    <sect1 id="transactions-demarcation">
        <title>数据库事务声明</title>
        <para>
						数据库（或者系统）事务的声明总是必须的。在数据库事务之外，就无法和数据库通讯（这可能会让那些习惯于
						自动提交事务模式的开发人员感到迷惑）。永远使用清晰的事务声明，即使只读操作也是如此。进行
						显式的事务声明并不总是需要的，这取决于你的事务隔离级别和数据库的能力，但不管怎么说，声明事务总归有益无害。
        </para>
        <para>
						一个Hibernate应用程序可以运行在非托管环境中（也就是独立运行的应用程序，简单Web应用程序，
						或者Swing图形桌面应用程序），也可以运行在托管的J2EE环境中。在一个非托管环境中，Hibernate
						通常自己负责管理数据库连接池。应用程序开发人员必须手工设置事务声明，换句话说，就是手工启
						动，提交，或者回滚数据库事务。一个托管的环境通常提供了容器管理事务，例如事务装配通过可声
						明的方式定义在EJB session beans的部署描述符中。可编程式事务声明不再需要，即使是
						<literal>Session</literal> 的同步也可以自动完成。
        </para>
        <para>
						让持久层具备可移植性是人们的理想。Hibernate提供了一套称为<literal>Transaction</literal>的封装API，
						用来把你的部署环境中的本地事务管理系统转换到Hibernate事务上。这个API是可选的，但是我们强烈
						推荐你使用，除非你用CMT session bean。
        </para>
        <para>
            通常情况下，结束 <literal>Session</literal> 包含了四个不同的阶段:
        </para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    同步session(flush,刷出到磁盘）
                </para>
            </listitem>
            <listitem>
                <para>
                    提交事务
                </para>
            </listitem>
            <listitem>
                <para>
                   关闭session
                </para>
            </listitem>
            <listitem>
                <para>
                    处理异常
                </para>
            </listitem>
        </itemizedlist>


        <para>
						session的同步(flush,刷出）前面已经讨论过了，我们现在进一步考察在托管和非托管环境下的事务声明和异常处理。
        </para>

        <sect2 id="transactions-demarcation-nonmanaged">
            <title>非托管环境</title>
            <para>
                如果Hibernat持久层运行在一个非托管环境中，数据库连接通常由Hibernate的连接池机制
                来处理。session/transaction处理方式如下所示：
            </para>
            <programlisting><![CDATA[//Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>
            <para>
                你不需要显式<literal>flush()</literal>  <literal>Session</literal>  -  
                对<literal>commit()</literal>的调用会自动触发session的同步。
            </para>

            <para>
                调用 <literal>close()</literal> 标志session的结束。
                <literal>close()</literal>方法重要的暗示是，<literal>session</literal>释放了JDBC连接。
            </para>

            <para>
                这段Java代码是可移植的，可以在非托管环境和JTA环境中运行。
            </para>

            <para>
                你很可能从未在一个标准的应用程序的业务代码中见过这样的用法；致命的（系统）异常应该总是
                在应用程序“顶层”被捕获。换句话说，执行Hibernate调用的代码（在持久层）和处理
                <literal>RuntimeException</literal>异常的代码（通常只能清理和退出应用程序）应该在不同
                的应用程序逻辑层。这对于你设计自己的软件系统来说是一个挑战，只要有可能，你就应该使用
                J2EE/EJB容器服务。异常处理将在本章稍后进行讨论。
            </para>

           <para>
                请注意，你应该选择 <literal>org.hibernate.transaction.JDBCTransactionFactory</literal>
                (这是默认选项).
            </para>

        </sect2>

        <sect2 id="transactions-demarcation-jta">
            <title>使用JTA</title>
            <para>
               	如果你的持久层运行在一个应用服务器中（例如，在EJB session beans的后面），Hibernate获取
               	的每个数据源连接将自动成为全局JTA事务的一部分。Hibernate提供了两种策略进行JTA集成。
            </para>

             <para>
                如果你使用bean管理事务（BMT），可以通过使用Hibernate的 <literal>Transaction</literal> API来告诉
                应用服务器启动和结束BMT事务。因此，事务管理代码和在非托管环境下是一样的。
            </para>

           <programlisting><![CDATA[// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

            <para>
               在CMT方式下，事务声明是在session bean的部署描述符中，而不需要编程。
               除非你设置了属性<literal>hibernate.transaction.flush_before_completion</literal>和
               <literal>hibernate.transaction.auto_close_session</literal>为<literal>true</literal>，
               否则你必须自己同步和关闭<literal>Session</literal>。Hibernate可以为你自动同步和关闭
               <literal>Session</literal>。你唯一要做的就是当发生异常时进行事务回滚。幸运的是，
               在一个CMT bean中，事务回滚甚至可以由容器自动进行，因为由session bean方法抛出的未处理的
               <literal>RuntimeException</literal>异常可以通知容器设置全局事务回滚。<emphasis>这意味着
               在CMT中，你完全无需使用Hibernate的<literal>Transaction</literal> API 。</emphasis>
            </para>

            <para>
                请注意，当你配置Hibernate事务工厂的时候，在一个BMT session bean中，你应该选择
                <literal>org.hibernate.transaction.JTATransactionFactory</literal>，在一个
                CMT session bean中选择<literal>org.hibernate.transaction.CMTTransactionFactory</literal>。
                记住，同时也要设置<literal>org.hibernate.transaction.manager_lookup_class</literal>。
            </para>

            <para>
								如果你使用CMT环境，并且让容器自动同步和关闭session，你可能也希望在你代码的不同部分使用
								同一个session。一般来说，在一个非托管环境中，你可以使用一个<literal>ThreadLocal</literal>
								变量来持有这个session，但是单个EJB方法调用可能会在不同的线程中执行（举例来说，一个session 
								bean调用另一个session bean）。如果你不想在应用代码中被传递<literal>Session</literal>对
								象实例的问题困扰的话，那么<literal>SessionFactory</literal> 提供的
								<literal>getCurrentSession()</literal>方法就很适合你，该方法返回一个绑定到JTA事务
								上下文环境中的session实例。这也是把Hibernate集成到一个应用程序中的最简单的方法！这个“当
								前的”session总是可以自动同步和自动关闭（不考虑上述的属性设置）。我们的session/transaction
								管理代码减少到如下所示：
            </para>

           <programlisting><![CDATA[// CMT idiom
Session sess = factory.getCurrentSession();

// do some work
...

]]></programlisting>

            <para>
                换句话来说，在一个托管环境下，你要做的所有的事情就是调用
                <literal>SessionFactory.getCurrentSession()</literal>，然后进行你的数据访问，把其余的工作
                交给容器来做。事务在你的session bean的部署描述符中以可声明的方式来设置。session的生命周期完全
                由Hibernate来管理。
            </para>
            
            <para>
                对<literal>after_statement</literal>连接释放方式有一个警告。因为JTA规范的一个很愚蠢的限制，Hibernate不可能自动清理任何未关闭的<literal>ScrollableResults</literal> 或者<literal>Iterator</literal>，它们是由<literal>scroll()</literal>或<literal>iterate()</literal>产生的。你<emphasis>must</emphasis>通过在<literal>finally</literal>块中，显式调用<literal>ScrollableResults.close()</literal>或者<literal>Hibernate.close(Iterator)</literal>方法来释放底层数据库游标。(当然，大部分程序完全可以很容易的避免在CMT代码中出现<literal>scroll()</literal>或<literal>iterate()</literal>。)
            </para>


        </sect2>

        <sect2 id="transactions-demarcation-exceptions">
            <title>异常处理</title>
            <para>
                如果 <literal>Session</literal> 抛出异常 (包括任何<literal>SQLException</literal>), 
                你应该立即回滚数据库事务，调用 <literal>Session.close()</literal> ，丢弃该
                <literal>Session</literal>实例。<literal>Session</literal>的某些方法可能会导致session
                处于不一致的状态。所有由Hibernate抛出的异常都视为不可以恢复的。确保在
                <literal>finally</literal> 代码块中调用<literal>close()</literal>方法，以关闭掉
                <literal>Session</literal>。
            </para>
            <para>
								<literal>HibernateException</literal>是一个非检查期异常（这不同于Hibernate老的版本），
								它封装了Hibernate持久层可能出现的大多数错误。我们的观点是，不应该强迫应用程序开发人员
								在底层捕获无法恢复的异常。在大多数软件系统中，非检查期异常和致命异常都是在相应方法调用
								的堆栈的顶层被处理的（也就是说，在软件上面的逻辑层），并且提供一个错误信息给应用软件的用户
								（或者采取其他某些相应的操作）。请注意，Hibernate也有可能抛出其他并不属于
								<literal>HibernateException</literal>的非检查期异常。这些异常同样也是无法恢复的，应该
								采取某些相应的操作去处理。
            </para>
            <para>
								在和数据库进行交互时，Hibernate把捕获的<literal>SQLException</literal>封装为Hibernate的
								<literal>JDBCException</literal>。事实上，Hibernate尝试把异常转换为更有实际含义
								的<literal>JDBCException</literal>异常的子类。底层的<literal>SQLException</literal>可以
								通过<literal>JDBCException.getCause()</literal>来得到。Hibernate通过使用关联到
								<literal>SessionFactory</literal>上的<literal>SQLExceptionConverter</literal>来
								把<literal>SQLException</literal>转换为一个对应的<literal>JDBCException</literal>
								异常的子类。默认情况下，<literal>SQLExceptionConverter</literal>可以通过配置dialect
								选项指定；此外，也可以使用用户自定义的实现类（参考javadocs
								 <literal>SQLExceptionConverterFactory</literal>类来了解详情）。标准的
								 <literal>JDBCException</literal>子类型是：
            </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>JDBCConnectionException</literal> - 指明底层的JDBC通讯出现错误
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>SQLGrammarException</literal> - 指明发送的SQL语句的语法或者格式错误
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>ConstraintViolationException</literal> - 指明某种类型的约束违例错误
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>LockAcquisitionException</literal> - 指明了在执行请求操作时，获取
                        所需的锁级别时出现的错误。
                        
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>GenericJDBCException</literal> - 不属于任何其他种类的原生异常
                    </para>
                </listitem>
            </itemizedlist>


        </sect2>

    </sect1>

    <sect1 id="transactions-optimistic">
        <title>乐观并发控制(Optimistic concurrency control)</title>
        <para>
            唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本化的乐观并发控制。版本检查使用版本号、
            或者时间戳来检测更新冲突（并且防止更新丢失）。Hibernate为使用乐观并发控制的代码提供了三种可
            能的方法，应用程序在编写这些代码时，可以采用它们。我们已经在前面应用程序长事务那部分展示了
            乐观并发控制的应用场景，此外，在单个数据库事务范围内，版本检查也提供了防止更新丢失的好处。
        </para>

        <sect2 id="transactions-optimistic-manual">
            <title>应用程序级别的版本检查(Application version checking)</title>
            <para>                
								 未能充分利用Hibernate功能的实现代码中，每次和数据库交互都需要一个新的
								 <literal>Session</literal>，而且开发人员必须在显示数据之前从数据库中重
								 新载入所有的持久化对象实例。这种方式迫使应用程序自己实现版本检查来确保
								 应用程序事务的隔离，从数据访问的角度来说是最低效的。这种使用方式和
								 entity EJB最相似。
            </para>

            <programlisting><![CDATA[// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();
int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion!=foo.getVersion ) throw new StaleObjectStateException();
foo.setProperty("bar");
t.commit();
session.close();]]></programlisting>

            <para>
                <literal>version</literal> 属性使用 <literal>&lt;version&gt;</literal>来映射，如果对象
                是脏数据，在同步的时候，Hibernate会自动增加版本号。
            </para>

            <para>
								当然，如果你的应用是在一个低数据并发环境下，并不需要版本检查的话，你照样可以使用
								这种方式，只不过跳过版本检查就是了。在这种情况下，<emphasis>最晚提交生效</emphasis>
								（<emphasis>last commit wins</emphasis>）就是你的应用程序长事务的默认处理策略。
								请记住这种策略可能会让应用软件的用户感到困惑，因为他们有可能会碰上更新丢失掉却没
								有出错信息，或者需要合并更改冲突的情况。
            </para>

            <para>
                很明显，手工进行版本检查只适合于某些软件规模非常小的应用场景，对于大多数软件应用场景
                来说并不现实。通常情况下，不仅是单个对象实例需要进行版本检查，整个被修改过的关
                联对象图也都需要进行版本检查。作为标准设计范例，Hibernate使用长生命周期
                <literal>Session</literal>的方式，或者脱管对象实例的方式来提供自动版本检查。
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-longsession">
            <title>长生命周期session和自动版本化</title>
            <para>
               单个 <literal>Session</literal>实例和它所关联的所有持久化对象实例都被用于整个
               应用程序事务。Hibernate在同步的时候进行对象实例的版本检查，如果检测到并发修
               改则抛出异常。由开发人员来决定是否需要捕获和处理这个异常（通常的抉择是给用户
               提供一个合并更改，或者在无脏数据情况下重新进行业务操作的机会）。
            </para>
            <para>
               在等待用户交互的时候， <literal>Session</literal> 断开底层的JDBC连接。这种方式
               以数据库访问的角度来说是最高效的方式。应用程序不需要关心版本检查或脱管对象实例
               的重新关联，在每个数据库事务中，应用程序也不需要载入读取对象实例。
            </para>

            <programlisting><![CDATA[// foo is an instance loaded earlier by the Session
session.reconnect(); // Obtain a new JDBC connection
Transaction t = session.beginTransaction();
foo.setProperty("bar");
t.commit(); // End database transaction, flushing the change and checking the version
session.disconnect(); // Return JDBC connection ]]></programlisting>

            <para>
								<literal>foo</literal> 对象始终和载入它的<literal>Session</literal>相关联。
								<literal>Session.reconnect()</literal>获取一个新的数据库连接（或者
								你可以提供一个），并且继续当前的session。<literal>Session.disconnect()</literal>
								方法把session与JDBC连接断开，把数据库连接返回到连接池（除非是你自己提供的数据
								库连接）。在Session重新连接上数据库连接之后，你可以对任何可能被其他事务更新过
								的对象调用<literal>Session.lock()</literal>，设置<literal>LockMode.READ</literal>
								 锁定模式，这样你就可以对那些你不准备更新的数据进行强制版本检查。此外，你并不需要
								 锁定那些你<emphasis>准备</emphasis>更新的数据。
            </para>

            <para>
                假若对<literal>disconnect()</literal>和<literal>reconnect()</literal>的显式调用发生得太频繁了，你可以使用<literal>hibernate.connection.release_mode</literal>来代替。
            </para>

            <para>
                如果在用户思考的过程中，<literal>Session</literal>因为太大了而不能保存，那么这种模式是有
                问题的。举例来说，一个<literal>HttpSession</literal>应该尽可能的小。由于
                <literal>Session</literal>是一级缓存，并且保持了所有被载入过的对象，因此
                我们只应该在那些少量的request/response情况下使用这种策略。而且在这种情况下，
                <literal>Session</literal> 里面很快就会有脏数据出现，因此请牢牢记住这一建议。
            </para>

            <para>
                此外，也请注意，你应该让与数据库连接断开的<literal>Session</literal>对持久层保持
                关闭状态。换句话说，使用有状态的EJB session bean来持有<literal>Session</literal>，
                而不要把它传递到web层（甚至把它序列化到一个单独的层），保存在<literal>HttpSession</literal>中。
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-detached">
            <title>脱管对象(deatched object)和自动版本化</title>

            <para>
                这种方式下，与持久化存储的每次交互都发生在一个新的<literal>Session</literal>中。
                然而，同一持久化对象实例可以在多次与数据库的交互中重用。应用程序操纵脱管对象实例
                的状态，这个脱管对象实例最初是在另一个<literal>Session</literal> 中载入的，然后
                调用 <literal>Session.update()</literal>，<literal>Session.saveOrUpdate()</literal>, 或者
                <literal>Session.merge()</literal> 来重新关联该对象实例。
            </para>

            <programlisting><![CDATA[// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();]]></programlisting>

            <para>
                Hibernate会再一次在同步的时候检查对象实例的版本，如果发生更新冲突，就抛出异常。
            </para>

            <para>
                如果你确信对象没有被修改过，你也可以调用<literal>lock()</literal> 来设置
                <literal>LockMode.READ</literal>（绕过所有的缓存，执行版本检查），从而取
                代 <literal>update()</literal>操作。
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-customizing">
            <title>定制自动版本化行为</title>
            <para>
               对于特定的属性和集合，通过为它们设置映射属性<literal>optimistic-lock</literal>的值
               为<literal>false</literal>，来禁止Hibernate的版本自动增加。这样的话，如果该属性
               脏数据，Hibernate将不再增加版本号。
            </para>

            <para>
								遗留系统的数据库Schema通常是静态的，不可修改的。或者，其他应用程序也可能访问同一数据
								库，根本无法得知如何处理版本号，甚至时间戳。在以上的所有场景中，实现版本化不能依靠
								数据库表的某个特定列。在<literal>&lt;class&gt;</literal>的映射中设置
								<literal>optimistic-lock="all"</literal>可以在没有版本或者时间戳属性映射的情况下实现
								版本检查，此时Hibernate将比较一行记录的每个字段的状态。请注意，只有当Hibernate能够比
								较新旧状态的情况下，这种方式才能生效，也就是说，
								你必须使用单个长生命周期<literal>Session</literal>模式，而不能使用
								session-per-request-with-detached-objects模式。
            </para>

            <para>
               有些情况下，只要更改不发生交错，并发修改也是允许的。当你在<literal>&lt;class&gt;</literal>
               的映射中设置<literal>optimistic-lock="dirty"</literal>，Hibernate在同步的时候将只比较有脏
               数据的字段。
            </para>

            <para>
                在以上所有场景中，不管是专门设置一个版本/时间戳列，还是进行全部字段/脏数据字段比较，
                Hibernate都会针对每个实体对象发送一条<literal>UPDATE</literal>（带有相应的
                <literal>WHERE</literal>语句 ）的SQL语句来执行版本检查和数据更新。如果你对关联实体
                设置级联关系使用传播性持久化（transitive persistence），那么Hibernate可能会执行不必
                要的update语句。这通常不是个问题，但是数据库里面对<emphasis>on update</emphasis>点火
                的触发器可能在脱管对象没有任何更改的情况下被触发。因此，你可以在
                <literal>&lt;class&gt;</literal>的映射中，通过设置<literal>select-before-update="true"</literal>
                来定制这一行为，强制Hibernate <literal>SELECT</literal>这个对象实例，从而保证，
                在更新记录之前，对象的确是被修改过。
            </para>

        </sect2>

    </sect1>

    <sect1 id="transactions-locking">
        <title>悲观锁定(Pessimistic Locking)</title>
        <para>
           用户其实并不需要花很多精力去担心锁定策略的问题。通常情况下，只要为JDBC连接指定一下隔
           离级别，然后让数据库去搞定一切就够了。然而，高级用户有时候希望进行一个排它的悲观锁定，
           或者在一个新的事务启动的时候，重新进行锁定。
        </para>

        <para>
            Hibernate总是使用数据库的锁定机制，从不在内存中锁定对象！
        </para>

        <para>
            类<literal>LockMode</literal> 定义了Hibernate所需的不同的锁定级别。一个锁定
            可以通过以下的机制来设置:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    当Hibernate更新或者插入一行记录的时候，锁定级别自动设置为<literal>LockMode.WRITE</literal>。
                </para>
            </listitem>
            <listitem>
                <para>
                    当用户显式的使用数据库支持的SQL格式<literal>SELECT ... FOR UPDATE</literal> 
                    发送SQL的时候，锁定级别设置为<literal>LockMode.UPGRADE</literal> 
                </para>
            </listitem>
            <listitem>
                <para>
                    当用户显式的使用Oracle数据库的SQL语句<literal>SELECT ... FOR UPDATE NOWAIT</literal>
                    的时候，锁定级别设置<literal>LockMode.UPGRADE_NOWAIT</literal> 
                </para>
            </listitem>
            <listitem>
                <para>
                    当Hibernate在“可重复读”或者是“序列化”数据库隔离级别下读取数据的时候，锁定模式
                    自动设置为<literal>LockMode.READ</literal>。这种模式也可以通过用户显式指定进行设置。
                </para>
            </listitem>
        <listitem>
        <para>
						<literal>LockMode.NONE</literal> 代表无需锁定。在<literal>Transaction</literal>结束时，
						所有的对象都切换到该模式上来。与session相关联的对象通过调用<literal>update()</literal>
						或者<literal>saveOrUpdate()</literal>脱离该模式。
        </para>
        </listitem>
        </itemizedlist>

        <para>
            "显式的用户指定"可以通过以下几种方式之一来表示:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    调用 <literal>Session.load()</literal>的时候指定<literal>锁定模式(LockMode)</literal>。
                </para>
            </listitem>
            <listitem>
                <para>
                    调用<literal>Session.lock()</literal>。
                </para>
            </listitem>
            <listitem>
                <para>
                    调用<literal>Query.setLockMode()</literal>。
                </para>
            </listitem>
        </itemizedlist>

        <para>
           如果在<literal>UPGRADE</literal>或者<literal>UPGRADE_NOWAIT</literal>锁定模式下调
           用<literal>Session.load()</literal>，并且要读取的对象尚未被session载入过，那么对象
           通过<literal>SELECT ... FOR UPDATE</literal>这样的SQL语句被载入。如果为一个对象调用
           <literal>load()</literal>方法时，该对象已经在另一个较少限制的锁定模式下被载入了，那
           么Hibernate就对该对象调用<literal>lock()</literal> 方法。
        </para>

        <para>
            如果指定的锁定模式是<literal>READ</literal>, <literal>UPGRADE</literal> 或
            <literal>UPGRADE_NOWAIT</literal>，那么<literal>Session.lock()</literal>就
            执行版本号检查。（在<literal>UPGRADE</literal> 或者<literal>UPGRADE_NOWAIT</literal>
            锁定模式下，执行<literal>SELECT ... FOR UPDATE</literal>这样的SQL语句。）
        </para>

        <para>
           如果数据库不支持用户设置的锁定模式，Hibernate将使用适当的替代模式（而不是扔出异常）。
           这一点可以确保应用程序的可移植性。
        </para>
    </sect1>

</chapter>

