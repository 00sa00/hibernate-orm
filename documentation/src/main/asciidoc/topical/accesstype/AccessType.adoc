= AccessType
:toc:

`AccessType` refers to the JPA notion represented by the `javax.persistence.AccessType` enum.  Even though
AccessType is a single value, it actually represents 3 related concepts:

# Determining which fields/methods constitute a persistent attribute.
# Indicating where to look for mapping annotations for each persistent attribute.
# How the attribute (its value) is accessed at runtime

Unfortunately the JPA specification is not overly clear about how the AccessType value defines the
answers to these 3 questions in all cases.  Often that is left up to each provider to decide.  So here we will
discuss how Hibernate answers the 3 AccessType-related questions in different situations.  By default, Hibernate
tries to keep the explanation for how it answers these questions simple.  AccessType defines 2 possible values: FIELD
and PROPERTY.

For Hibernate, FIELD access means that:

# A persistent attribute is identified by its Class field
# The mapping annotations for the persistent attribute are located on the Class field
# At runtime we access the persistent attribute's value directly via the field.

PROPERTY access means that:

# A persistent attribute is identified by its JavaBeans-style getter and setter on a Class
# The mapping annotations for the persistent attribute are located on the Class getter method
# At runtime we access the persistent attribute's value via the getter/setter methods.

WARNING: Placing annotations on setters is NEVER appropriate.


== Background

Hibernate has always had a notion of "property access strategies" to allow users to control the runtime access part.
But, as back in those days there were no annotations and just XML-based mappings, the other 2 were never a concern.
Initially JPA had no such explicit concept, although it did implicitly define runtime access based on placement of
mapping annotations.  JPA 2.0 introduced the concept of `javax.persistence.AccessType` to allow better control over
defining where the persistence provider look for mapping annotations and how it access the attribute values at
runtime.  JPA allows defining AccessType at a number of "levels".


== Implicit (hierarchy) level

The implicit access type for an entity hierarchy defines how access type is defined when there is no explicitly
defined AccessType.  To determine implicit hierarchy access type, Hibernate looks for the annotation marking the
identifier for the entity hierarchy (either @Id or @EmbeddedId).  The placement (field or getter) defines the implicit
access type for the hierarchy.  Let's look at an example:


[[hierarchy-level-field]]
.Hierarchy-level FIELD access
====
[source, JAVA]
----
@Entity
public class Document {
    @Id
    private Integer id;
    private String title;
    @Lob
    private Clob content;

    @Transient
    private int hashCode;
}

@Entity
public class PublishedDocument extends Document {
    private String isbn;
    @Temporal(DATE)
    private Date publishDate;
}
----
====

Here we have implicit hierarchy-level field access because of the placement of @Id on a field, which means:

* We look at the declared fields for each class to determine its persistent attributes.  For the `Document` class,
	that means we have 3 fields that would be considered persistent attributes: `id`, `title`, and `content`; for
	`PublishedDocument` we have 2: `isbn` and `publishDate`.  Given field "access type", to indicate that a particular
	field is not persistent, the field would be annotated with the `javax.persistence.Transient` annotation; here we
	see an example of that for the `hashCode` field.
* We use the annotations attached to those fields as the mapping annotations for the persistent attribute it indicates.
	Annotations on the getter associated with that field (if one/any) are ignored (although we do try to log warnings
	in such cases).
* In terms of runtime access, Hibernate will use direct field access (via reflection) to get and set attribute values
	using `java.lang.reflection.Field`.


Implicit property access works similarly:

[[hierarchy-level-property]]
.Hierarchy-level PROPERTY access
====
[source, JAVA]
----
@Entity
public class Document {
    private Integer id;
    private String title;
    private Clob content;

    @Id
    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    @Lob
    public Clob getContent() { return content; }
    public void setContent(Clob content) { this.content = content; }
}

@Entity
public class PublishedDocument extends Document {
    private String isbn;
    private Date publishDate;

    public String getIsbn() { return isbn; }
    public void setIsbn(String isbn) { this.isbn = isbn; }

    @Temporal(DATE)
    public Date getPublishDate() { return publishDate; }
    public void setPublishDate(Date publishDate) { this.publishDate = publishDate; }
}
----
====

In this case, we have implicit hierarchy-level property access because of the placement of @Id on the getter,
which here means:

* We look at the declared methods for each class looking for JavaBean-style getters to determine the persistent
	attributes for that class.  For the `Document` class, we have 3 getters that would indicate persistent attributes:
	`getId()`, `getTitle()` and `getContent()`; for `PublishedDocument` we have 2: `getIsbn()` and `getPublishDate()`.
	The "attribute name" is taken following JavaBean-conventions.  To indicate that a getter does is not indicate a
	persistent attribute, the getter would be annotated with the `javax.persistence.Transient` annotation.
* We use the annotations attached to those getter methods as the mapping annotations for the persistent attribute
	it indicates.  Annotations on the field associated with that getter (if one/any) are ignored (although, again, we do
	try to log warnings in such cases).
* In terms of runtime access, Hibernate will use getter/setter access (via reflection) to get and set attribute values
	using `java.lang.reflection.Method`.


== Class level

JPA allows declaring the "access type" to use via the `javax.persistence.Access` annotation which can be applied to
either a class or a field/method.  We will look at applying `javax.persistence.Access` to a field/method in the next
section.  For now let's focus on the implications of applying it to a class.

Let's go back to the <<hierarchy-level-field,first example>> we saw where we had implicit hierarchy-level field
access.  But lets instead use `javax.persistence.Access` and see what affect that has:


[[class-level-property]]
.Class-level PROPERTY access
====
[source, JAVA]
----
@Entity
public class Document {
    @Id
    private Integer id;
    private String title;
    @Lob
    private Clob content;
}

@Entity
@Access(PROPERTY)
public class PublishedDocument extends Document {
    private String isbn;
    private Date publishDate;

    public String getIsbn() { return isbn; }
    public void setIsbn(String isbn) { this.isbn = isbn; }

    @Temporal(DATE)
    public Date getPublishDate() { return publishDate; }
    public void setPublishDate(Date publishDate) { this.publishDate = publishDate; }
}
----
====

The hierarchy still has an implicit field access type.  The `Document` class implicitly uses field access as the
hierarchy default.  The `PublishedDocument` class however overrides that to say that it uses property access.  This
class-level `javax.persistence.Access` override is only in effect for that class; if another entity extended from
`PublishedClass` and did not specify a `javax.persistence.Access`, that entity subclass would use field access
as the hierarchy default.  But in terms of the `PublishedDocument` class, it has the same effect we saw in the
<<hierarchy-level-property,second example>> in that we now look to the getters within the `PublishedDocument` as
defining persistent attributes and we use the getter and setter at runtime when access `PublishedDocument` attributes
(but not the attributes it inherits).

Similarly, the explicit class-level access type can be set to FIELD:

[[class-level-field]]
.Class-level FIELD access
====
[source, JAVA]
----
@Entity
public class Document {
    private Integer id;
    private String title;
    private Clob content;

    @Id
    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    @Lob
    public Clob getContent() { return content; }
    public void setContent(Clob content) { this.content = content; }
}

@Entity
@Access(PROPERTY)
public class PublishedDocument extends Document {
    private String isbn;
    @Temporal(DATE)
    private Date publishDate;
}
----
====


== Attribute-level

JPA also says that access type can be explicitly specified on an individual attribute...